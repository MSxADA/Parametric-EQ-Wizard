<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio EQ Preset Visualizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Using D3.js v3 for compatibility with the scaling functions -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.17/d3.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* Custom CSS for the Vaporwave theme and glowing effects */
        :root {
            --bg-color: #1a101f;
            --primary-text: #e0e0e0;
            --neon-purple: #9d00ff;
            --neon-yellow: #fff000;
            --hot-pink: #ff1493;
            --neon-blue: #00dfff;
            --neon-green: #39ff14;
        }

        body {
            background-color: var(--bg-color);
            color: var(--primary-text);
            font-family: 'Inter', sans-serif;
        }

        .glow-border {
            box-shadow: 0 0 5px var(--neon-purple), 0 0 10px var(--neon-purple), 0 0 15px var(--neon-purple);
        }

        .glow-text-pink {
            text-shadow: 0 0 3px var(--hot-pink), 0 0 5px var(--hot-pink);
        }
        
        .preset-btn {
            transition: all 0.2s ease-in-out;
            border-color: var(--neon-blue);
        }

        .preset-btn:hover {
            background-color: var(--neon-blue);
            color: var(--bg-color);
            transform: translateY(-2px);
            box-shadow: 0 0 8px var(--neon-blue);
        }

        .preset-btn.active {
            background-color: var(--hot-pink);
            color: var(--bg-color);
            border-color: var(--hot-pink);
            box-shadow: 0 0 10px var(--hot-pink);
        }

        .table-header {
            color: var(--neon-yellow);
        }

        /* Updated classes for a brighter neon gain/cut text glow */
        .text-neon-gain {
            color: var(--neon-green);
            text-shadow: 0 0 5px var(--neon-green);
        }

        .text-neon-cut {
            color: var(--hot-pink);
            text-shadow: 0 0 5px var(--hot-pink);
        }
    </style>
</head>
<body class="antialiased">

    <div class="min-h-screen container mx-auto p-4 sm:p-6 lg:p-8">
        <header class="text-center mb-8">
            <h1 class="text-4xl sm:text-5xl font-bold tracking-wider glow-text-pink">Audio EQ Visualizer</h1>
            <p class="text-lg text-gray-400 mt-2">Crafted presets based on audio science for superior sound.</p>
        </header>

        <main class="grid grid-cols-1 lg:grid-cols-3 gap-8">
            <!-- Left Column: Controls -->
            <div class="lg:col-span-1 space-y-8">
                <!-- Listening Style Presets -->
                <div>
                    <h2 class="text-2xl font-semibold mb-4 border-b-2 border-hot-pink pb-2 glow-text-pink">Listening Styles</h2>
                    <div id="style-presets" class="grid grid-cols-2 gap-3">
                        <!-- Buttons will be injected by JS -->
                    </div>
                </div>

                <!-- Genre Presets -->
                <div>
                    <h2 class="text-2xl font-semibold mb-4 border-b-2 border-hot-pink pb-2 glow-text-pink">Music Genres</h2>
                    <div id="genre-presets" class="grid grid-cols-2 gap-3">
                        <!-- Buttons will be injected by JS -->
                    </div>
                </div>
            </div>

            <!-- Right Column: Visualization and Data -->
            <div class="lg:col-span-2 space-y-8">
                <!-- EQ Curve Visualizer -->
                <div class="bg-black bg-opacity-40 p-4 rounded-lg border-2 border-purple-500 glow-border">
                    <h3 id="current-preset-title" class="text-xl font-bold text-center mb-4 text-neon-yellow">Select a Preset</h3>
                    <div class="relative w-full aspect-[2/1]">
                         <canvas id="eq-canvas" class="w-full h-full"></canvas>
                    </div>
                </div>

                <!-- EQ Settings Table -->
                <div class="bg-black bg-opacity-40 p-4 rounded-lg border-2 border-purple-500 glow-border">
                     <h3 class="text-xl font-bold text-center mb-4 text-neon-yellow">Parametric EQ Settings</h3>
                     <div class="overflow-x-auto">
                        <table class="w-full text-center">
                            <thead>
                                <tr>
                                    <th class="p-2 table-header">Filter</th>
                                    <th class="p-2 table-header">Type</th>
                                    <th class="p-2 table-header">Frequency (Hz)</th>
                                    <th class="p-2 table-header">Gain (dB)</th>
                                    <th class="p-2 table-header">Q-Factor</th>
                                </tr>
                            </thead>
                            <tbody id="settings-table-body">
                                <!-- Data will be injected by JS -->
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            // --- DATA: PRESETS ---
            const presets = {
                // Listening Styles
                "Fuller Bass & Warmth": [
                    { type: 'lowshelf', freq: 120, gain: 3.0, q: 0.7 },
                    { type: 'peak', freq: 350, gain: -1.5, q: 1.4 },
                    { type: 'peak', freq: 3000, gain: 1.0, q: 2.0 }
                ],
                "Energetic & Forward": [
                    { type: 'peak', freq: 80, gain: 1.5, q: 1.2 },
                    { type: 'peak', freq: 2500, gain: 2.5, q: 1.8 },
                    { type: 'highshelf', freq: 8000, gain: 2.0, q: 0.7 }
                ],
                "Crisp Vocals & Detail": [
                    { type: 'peak', freq: 250, gain: -2.0, q: 1.5 },
                    { type: 'peak', freq: 4000, gain: 3.0, q: 2.5 },
                    { type: 'highshelf', freq: 10000, gain: 2.5, q: 0.9 }
                ],
                "Smooth & Relaxed": [
                    { type: 'peak', freq: 2500, gain: -2.0, q: 1.5 },
                    { type: 'peak', freq: 5000, gain: -2.5, q: 2.0 },
                    { type: 'highshelf', freq: 10000, gain: -1.5, q: 0.7 }
                ],
                "Late Night Listening": [ // Fletcher-Munson curve approximation
                    { type: 'lowshelf', freq: 150, gain: 4.0, q: 0.7 },
                    { type: 'peak', freq: 1000, gain: -2.0, q: 0.8 },
                    { type: 'highshelf', freq: 7000, gain: 3.0, q: 0.7 }
                ],
                "Theater (Movies)": [
                    { type: 'lowshelf', freq: 80, gain: 4.5, q: 0.7 },
                    { type: 'peak', freq: 300, gain: -2.5, q: 1.2 },
                    { type: 'peak', freq: 3500, gain: 3.0, q: 2.0 }
                ],
                // Music Genres
                "Classic Rock": [
                    { type: 'peak', freq: 100, gain: 3.0, q: 1.0 },
                    { type: 'peak', freq: 800, gain: -2.0, q: 1.4 },
                    { type: 'peak', freq: 5000, gain: 2.5, q: 1.8 }
                ],
                "Pop": [
                    { type: 'lowshelf', freq: 90, gain: 3.5, q: 0.7 },
                    { type: 'peak', freq: 3000, gain: 2.0, q: 2.0 },
                    { type: 'highshelf', freq: 12000, gain: 3.0, q: 0.7 }
                ],
                "Jazz": [
                    { type: 'peak', freq: 80, gain: 2.0, q: 1.0 },
                    { type: 'peak', freq: 500, gain: -1.5, q: 1.5 },
                    { type: 'peak', freq: 7000, gain: 2.5, q: 2.5 }
                ],
                "Metal": [
                    { type: 'peak', freq: 80, gain: 4.0, q: 1.2 },
                    { type: 'peak', freq: 500, gain: -4.0, q: 1.0 },
                    { type: 'peak', freq: 4000, gain: 3.5, q: 1.5 }
                ],
                "Stoner Metal": [
                    { type: 'peak', freq: 120, gain: 4.0, q: 0.9 },
                    { type: 'peak', freq: 400, gain: 2.0, q: 0.8 },
                    { type: 'peak', freq: 1000, gain: -3.0, q: 1.2 },
                    { type: 'peak', freq: 3000, gain: -2.0, q: 2.0 },
                ],
                "Acoustic": [
                    { type: 'highpass', freq: 50, gain: 0, q: 0.7 }, // Simulate cutting boominess
                    { type: 'peak', freq: 200, gain: -2.5, q: 1.8 },
                    { type: 'peak', freq: 5000, gain: 2.0, q: 2.2 },
                    { type: 'highshelf', freq: 10000, gain: 1.5, q: 0.7 }
                ],
                "Classical": [
                    { type: 'peak', freq: 150, gain: 1.5, q: 1.0 },
                    { type: 'peak', freq: 2000, gain: 1.0, q: 2.0 },
                    { type: 'highshelf', freq: 8000, gain: 2.0, q: 1.0 }
                ],
                "Electronic/Dance": [
                    { type: 'lowshelf', freq: 100, gain: 4.5, q: 0.8 },
                    { type: 'peak', freq: 800, gain: -2.0, q: 1.5 },
                    { type: 'highshelf', freq: 12000, gain: 3.5, q: 0.9 }
                ],
                "R&B": [
                    { type: 'lowshelf', freq: 80, gain: 4.0, q: 0.7 },
                    { type: 'peak', freq: 2000, gain: 2.0, q: 1.8 },
                    { type: 'peak', freq: 6000, gain: 1.5, q: 2.5 }
                ],
                "Rap": [
                    { type: 'lowshelf', freq: 70, gain: 5.0, q: 0.7 },
                    { type: 'peak', freq: 2500, gain: 2.5, q: 1.5 },
                    { type: 'highshelf', freq: 10000, gain: 2.0, q: 0.7 }
                ],
                "Country": [
                    { type: 'peak', freq: 150, gain: 2.0, q: 1.2 },
                    { type: 'peak', freq: 1500, gain: 2.5, q: 1.8 },
                    { type: 'peak', freq: 6000, gain: 1.5, q: 2.0 }
                ],
                "Funk & Soul": [
                    { type: 'peak', freq: 90, gain: 3.0, q: 1.0 },
                    { type: 'peak', freq: 600, gain: -1.5, q: 1.4 },
                    { type: 'peak', freq: 3000, gain: 2.0, q: 1.8 }
                ],
                "Reggae": [
                    { type: 'lowshelf', freq: 100, gain: 4.0, q: 0.7 },
                    { type: 'peak', freq: 250, gain: 2.0, q: 0.9 },
                    { type: 'peak', freq: 800, gain: -3.0, q: 1.2 },
                    { type: 'highshelf', freq: 5000, gain: 1.5, q: 0.7 }
                ]
            };
            
            const stylePresetKeys = ["Fuller Bass & Warmth", "Energetic & Forward", "Crisp Vocals & Detail", "Smooth & Relaxed", "Late Night Listening", "Theater (Movies)"];
            const genrePresetKeys = Object.keys(presets).filter(k => !stylePresetKeys.includes(k));

            const canvas = document.getElementById('eq-canvas');
            const ctx = canvas.getContext('2d');
            const stylePresetsContainer = document.getElementById('style-presets');
            const genrePresetsContainer = document.getElementById('genre-presets');
            const tableBody = document.getElementById('settings-table-body');
            const currentPresetTitle = document.getElementById('current-preset-title');
            
            let activePresetButton = null;

            function initialize() {
                createButtons(stylePresetKeys, stylePresetsContainer);
                createButtons(genrePresetKeys, genrePresetsContainer);
                setupCanvas();
                drawGrid();
            }

            function createButtons(keys, container) {
                keys.forEach(key => {
                    const button = document.createElement('button');
                    button.className = 'preset-btn w-full p-2 text-sm font-semibold border-2 rounded-md';
                    button.textContent = key;
                    button.dataset.preset = key;
                    button.addEventListener('click', handlePresetClick);
                    container.appendChild(button);
                });
            }

            function setupCanvas() {
                const dpr = window.devicePixelRatio || 1;
                const rect = canvas.getBoundingClientRect();
                canvas.width = rect.width * dpr;
                canvas.height = rect.height * dpr;
                ctx.scale(dpr, dpr);
            }
            
            function handlePresetClick(event) {
                const presetKey = event.target.dataset.preset;
                const presetData = presets[presetKey];

                if (activePresetButton) {
                    activePresetButton.classList.remove('active');
                }
                activePresetButton = event.target;
                activePresetButton.classList.add('active');

                updateUI(presetKey, presetData);
            }
            
            function updateUI(name, data) {
                currentPresetTitle.textContent = name;
                drawEQCurve(data);
                populateTable(data);
            }

            function populateTable(data) {
                tableBody.innerHTML = '';
                if (!data || data.length === 0) {
                    tableBody.innerHTML = `<tr><td colspan="5" class="p-4 text-gray-400">Select a preset to see its settings.</td></tr>`;
                    return;
                }
                data.forEach((band, index) => {
                    const row = document.createElement('tr');
                    row.className = 'border-b border-gray-700';
                    row.innerHTML = `
                        <td class="p-2">${index + 1}</td>
                        <td class="p-2 uppercase">${band.type === 'highpass' ? 'HPF' : band.type}</td>
                        <td class="p-2">${band.freq}</td>
                        <td class="p-2 font-bold ${band.gain > 0 ? 'text-neon-gain' : 'text-neon-cut'}">${band.gain.toFixed(1)}</td>
                        <td class="p-2">${band.q.toFixed(2)}</td>
                    `;
                    tableBody.appendChild(row);
                });
            }

            const minFreq = 20;
            const maxFreq = 20000;
            const minGain = -12;
            const maxGain = 12;

            const xScale = d3.scale.log().domain([minFreq, maxFreq]);
            const yScale = d3.scale.linear().domain([minGain, maxGain]);

            function drawGrid() {
                const width = canvas.clientWidth;
                const height = canvas.clientHeight;
                xScale.range([0, width]);
                yScale.range([height, 0]);

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.fillStyle = 'rgba(224, 224, 224, 0.7)';
                ctx.font = '11px Inter';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';

                const freqLines = [30, 60, 100, 200, 500, 1000, 2000, 5000, 10000];
                freqLines.forEach(freq => {
                    const x = xScale(freq);
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, height);
                    ctx.stroke();
                    const label = freq >= 1000 ? `${freq/1000}k` : freq;
                    ctx.fillText(label, x, height - 12);
                });

                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';
                for (let gain = minGain; gain <= maxGain; gain += 3) {
                    const y = yScale(gain);
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(width, y);
                    ctx.strokeStyle = (gain === 0) ? 'rgba(0, 223, 255, 0.5)' : 'rgba(255, 255, 255, 0.1)';
                    ctx.stroke();
                    if (gain !== 0) ctx.fillText(`${gain}dB`, 5, y - 5);
                }
            }

            function drawEQCurve(bands) {
                drawGrid(); 
                if (!bands || bands.length === 0) return;

                const width = canvas.clientWidth;
                const yZero = yScale(0);

                let lastX, lastY, lastGain;

                ctx.lineWidth = 3;
                ctx.shadowBlur = 15;

                for (let i = 0; i <= width; i++) {
                    const x = i;
                    const freq = xScale.invert(x);
                    const totalGain = calculateTotalGainAtFrequency(freq, bands);
                    const y = yScale(Math.max(minGain, Math.min(maxGain, totalGain)));

                    if (i > 0) {
                        const currentGainSign = Math.sign(totalGain);
                        const lastGainSign = Math.sign(lastGain);
                        
                        const boostColor = '#39ff14'; // neon-green
                        const cutColor = '#ff1493';   // hot-pink

                        // Check if the curve crossed the 0dB line
                        if (currentGainSign !== lastGainSign && currentGainSign !== 0 && lastGainSign !== 0) {
                            // Calculate the intersection point on the 0dB line
                            const x_intersect = lastX + (x - lastX) * (yZero - lastY) / (y - lastY);

                            // Draw segment before crossing
                            const prevColor = lastGain > 0 ? boostColor : cutColor;
                            ctx.beginPath();
                            ctx.strokeStyle = prevColor;
                            ctx.shadowColor = prevColor;
                            ctx.moveTo(lastX, lastY);
                            ctx.lineTo(x_intersect, yZero);
                            ctx.stroke();

                            // Draw segment after crossing
                            const currentColor = totalGain > 0 ? boostColor : cutColor;
                            ctx.beginPath();
                            ctx.strokeStyle = currentColor;
                            ctx.shadowColor = currentColor;
                            ctx.moveTo(x_intersect, yZero);
                            ctx.lineTo(x, y);
                            ctx.stroke();
                        } else {
                            // Draw a normal segment if no crossing
                            const color = totalGain >= 0 ? boostColor : cutColor;
                            ctx.beginPath();
                            ctx.strokeStyle = color;
                            ctx.shadowColor = color;
                            ctx.moveTo(lastX, lastY);
                            ctx.lineTo(x, y);
                            ctx.stroke();
                        }
                    }
                    
                    lastX = x;
                    lastY = y;
                    lastGain = totalGain;
                }

                ctx.shadowBlur = 0; // Reset shadow
                ctx.lineWidth = 1;

                // Draw emphasis points with their own glow, matching the boost/cut colors
                bands.forEach(band => {
                    if (band.type === 'highpass') return;
                    const x = xScale(band.freq);
                    const y = yScale(Math.max(minGain, Math.min(maxGain, calculateTotalGainAtFrequency(band.freq, bands))));
                    const pointColor = band.gain > 0 ? '#39ff14' : '#ff1493';

                    ctx.beginPath();
                    ctx.arc(x, y, 5, 0, 2 * Math.PI);
                    
                    ctx.shadowColor = pointColor;
                    ctx.shadowBlur = 10;
                    ctx.fillStyle = pointColor;
                    
                    ctx.fill();
                    ctx.shadowBlur = 0; // Reset shadow after each point
                });
            }

            function calculateTotalGainAtFrequency(targetFreq, bands) {
                let totalGain = 0;
                bands.forEach(band => {
                    const type = band.type;
                    const fc = Number(band.freq);
                    const G = Number(band.gain);
                    const Q = Number(band.q);

                    if (isNaN(fc) || isNaN(G) || isNaN(Q) || fc <= 0 || Q <= 0) {
                        return;
                    }

                    let gainAtFreq = 0;
                    switch (type) {
                        case 'lowshelf': {
                            const norm = targetFreq / fc;
                            gainAtFreq = G / (1 + Math.pow(norm, 2 * Q));
                            break;
                        }
                        case 'highshelf': {
                            const norm = targetFreq / fc;
                            const norm_q = Math.pow(norm, 2 * Q);
                            gainAtFreq = G * norm_q / (1 + norm_q);
                            break;
                        }
                        case 'peak': {
                            const bw = (fc / Q);
                            const term = Math.pow((targetFreq * targetFreq - fc * fc), 2) / (targetFreq * targetFreq * bw * bw);
                            gainAtFreq = G / Math.sqrt(1 + term);
                            break;
                        }
                        case 'highpass': {
                            if (targetFreq < fc) {
                                gainAtFreq = -24 * Math.log2(fc / targetFreq); 
                            } else {
                                gainAtFreq = 0;
                            }
                            break;
                        }
                        default:
                            gainAtFreq = 0;
                    }

                    if (!isNaN(gainAtFreq)) {
                        totalGain += gainAtFreq;
                    }
                });
                return totalGain;
            }

            initialize();
            populateTable([]);
            
            window.addEventListener('resize', () => {
                setupCanvas();
                const activePresetKey = activePresetButton ? activePresetButton.dataset.preset : null;
                if(activePresetKey) {
                    drawEQCurve(presets[activePresetKey]);
                } else {
                    drawGrid();
                }
            });
        });
    </script>

</body>
</html>
